#!/bin/bash

NAME=$(basename $0)
VERSION='0.0'

version() {
    echo "${NAME} v${VERSION}"
}

usage() {
    echo "
Usage: ${NAME} COMMAND [ARG] [OPTION...]

Commands:
    add <URL>     Clone and create new package from URL (expectedly
                  pointing to a git-repository). See more in 'Modes'.
    remove <PKG>  Remove PKG and all of its files.
    show <PKG>    Show metadata of PKG.
    path <PKG>    Print absolure path of PKG directory.
    reflect <PKG> Scan for executables in repository and create
                  symlinks.
    update <PKG>  Update package PKG, see 'Modes' for details.

    sync [<PKG>]  Sync package PKG (or all packages with no argument),
                  i.e. check for available updates.

    list          List packages.

    set <PKG> KEY[=VAL]
                  Set metadata value of KEY to VAL (without VAL,
                  show current value).

Options:
    options for 'add':
        -t        Add package in tag-mode
        -b        Add package in branch-mode
        -u        Force using URL as is

    options for 'add' and 'reflect':
        -d        Dry-run, don't download or create files

    options for 'reflect':
        -r <DIR>  Use subdirectory DIR instead of root directory
        -R        Scan directories recursively, not just root directory

    options for 'update':
        -f        Don't stop on uncommitted changes and don't ask to
                  select tag if more than one tag are available.

Modes:
    Packages are added and updated in one of the two modes:

    tag-mode      Local repository is cloned using a tag reference.
                  In this mode, when you update a package, we search
                  for a tag that is more recent than the current one,
                  and merge the local working branch.

                  When the attribute 'tag_pattern' is set, only tags
                  matching this pattern are considered.

    branch-mode   Local repository is cloned using a branch reference
                  (often master/main). Package is updated by merging
                  last commits into the local working branch.

    The \"local working branch\" is created when a repository is cloned,
    (useful if you like to mess with the source code). The name of this
    branch is defined in the config file.
    "
}


# terminal colors
BOLD="\033[1m"
CLEAR="\033[0m"
RED="\033[31m"
PINK="\033[35m"
YELLOW="\033[93m"
CYAN="\033[36m"
GREY="\033[90m"


# Exit program with optional error message
abort() {
    [ -n "$1" ] && echo "$1" >&2
    exit 1
}

# Check if user wants to proceed
check_proceed() {
    read -p "${1:-proceed?} [y/N]: "
    [ "$REPLY" == "y" ] || [ "$REPLY" == "yes" ] || exit
}

# Test if package metadata file exist
md_exists() {
    test -e "$MDD/$1"
}

# Remove package metadata
md_remove() {
    rm -eaf "$MDD/$1"
}

# Read package metadata and store into the AA 'md' (should
# be declared by calling function). Metadata consists of
# simple key-value pairs. As an exception, the 'bins' and
# 'libs' fields consist from key-values on their own: if
# calling function also wants those, it should additionally
# declare the AAs 'bins' and 'libs'.
md_load() {
    local key val
    while IFS=': ' read -r key val; do
        md[$key]="$val"
    done < "$MDD/$1"
}

# metadata can optinally contain list of binaries
# for which we've created symlinks (this can be 
# done with the 'reflect' command). this list
# should be stored in two additional files.
# calling function should declare two AA's:
# 'bins' and 'libs'.
md_load_links() {
    local key val
    if [ -e "$MDD/$1.bins" ]; then
        while IFS=': ' read -r key val; do
            bins[$key]="$val"
        done < "$MDD/$1.bins"
    fi

    if [ -e "$MDD/$1/libs" ]; then
        while IFS=': ' read -r key val; do
            libs[$key]="$val"
        done < "$MDD/$1.libs"
    fi
}

# save package metadata (i.e. key-value pairs
# of the AA 'md', overwrites file if it exists.
md_dump() {
    action="created"
    md_exists "$1" && md_remove "$1" && action="updated"

    local key fp="${MDD}/$1"
    touch "$fp" || abort "can't create '$fp'"
    for key in ${!md[@]}; do echo "$key: ${md[$key]}" >> "$fp"; done
    echo "$action metadata '$fp'"
}

# save the two lists of symlinks in auxiliary 
# metadata files, calling function should provide
# the AA's 'bins' and 'libs'
md_dump_links() {

    local x bf="${MD}/$1.bins" lf="${MD}/$1.libs"
    rm -f "$bf" "$lf"
    for x in ${!bins[@]}; do [ -n ${bins[$x]} ] && echo "${bins[$x]}: $x" >> "$bf"; done
    for x in ${!libs[@]}; do [ -n ${libs[$x]} ] && echo "${libs[$x]}: $x" >> "$lf"; done

}

md_list() {
    ls "$MDD" | grep -vE "\.(libs)|(bins)$"
}

set() {
    local -A md

    md_exists $1 || abort "package '$1' does not exist"
    md_load $1

    local key val
    read -r key val <<< $(echo "$2" | sed -E 's|^(\w+)=?(.*)$|\1 \2|')

    if [ -z "$val" ]; then
        [ ${md[$key]+_} ] && val="${md[$key]}"
        echo "$key = $val"
    else
        echo "$key = $val"
        if [ ${md[$key]+_} ]; then
            check_proceed "overwrite existing value [${md[$key]}]?"
        else
            check_proceed "write to package metadata?"
        fi

        md[$key]="$val"
        md_dump $1
    fi
}

path() {
    local -A md
    md_exists $1 || abort "package '$1' does not exist"
    md_load $1

    echo "$PKG/${md[path]}"
}

# list all packages by reading metadata directory
list() {
    local pkg
    local -A md

    if [ ! ${OPTS[no_header]} ]; then
        printf "************************* ******************** **************************************************\n"
        printf "%-25s %-20s %-50s\n" "package" "current head" "url"
        printf "************************* ******************** **************************************************\n"
    fi

    for pkg in $(md_list); do
        md=()
        md_load $pkg
        printf "%-25s %-20s %-50s\n" "$pkg" "${md[mode]} '${md[ref]}'" "${md[url]}"
    done
}

# show metadata of package
show() {
    md_exists $1 || abort "package '$1' does not exist"
    local -A md
    local key
    md_load "$1"

    if [ ! ${OPTS[no_header]} ]; then
        printf "**************** ******************************************\n"
        printf "        package: %b%s%b\n" "$BOLD" "$1" "$CLEAR"
        printf "**************** ******************************************\n"
    fi

    for key in ${!md[@]}; do printf "%15s: " "$key"; echo ${md[$key]}; done

    local bf="$MDD/$1.bins" lf="${MD}/$1.libs"
    printf "%15s: " "bins"
    [ -e "$bf" ] && wc -l "$bf" | cut -d' ' -f1 || echo 0
    printf "%15s: " "libs"
    [ -e "$lf" ] && wc -l "$lf" | cut -d' ' -f1 || echo 0
}

# remove package (i.e. remove its repository and metadata)
remove() {
    md_exists $1 || abort "package '$1' does not exist"
    local -A md
    md_load $1
    local path="${md[path]}"
    [ -n "$path" ] || abort "package '$1': missing path"
    [ -d "$PKG/$path" ] || abort "package '$1': invalid path '$path'"

	echo "warning: any local changes will be permanently lost"
    check_proceed "remove '$1'?"

    rm -rf "$PKG/$path" || abort
	echo "removed directory '$PKG/$path'"

	# TODO

    # local -A bins libs
    # md_load_links $1

    # local k
    # for k in ${!bins[@]}; do unlink "$BIN/$k" && echo "removed link '$BIN/$k'"; done
    # for k in ${!libs[@]}; do unlink "$LIB/$k" && echo "removed link '$LIB/$k'"; done

    md_remove $1
    echo -e "${BOLD}package '$1' removed${CLEAR}"
}

# Parse URL of a git-repository (reference:
# https://www.git-scm.com/docs/git-clone#_git_urls),
# and write to 'scheme', 'host', 'port', 'path' and 'pkg'.
url_parse() {
    # parse http-style url
    IFS='# ' read -r scheme host port path \
        <<< $(echo "$1" | sed -E 's|^([a-z]+://)?([^/:]+)(:[0-9]+)?(/.*)|\1# \2# \3# \4|')

    # parse ssh-style url
    if [ -z "$host" ] || [ -z "$path" ]; then
        IFS='# ' read -r scheme host path \
            <<< $(echo "$1" | sed -E 's|^([a-z]+@)([^/:]+):(.+)|\1# \2# \3#|')
    fi

    [ -n "$host" ] && [ -n "$path" ] || return 1

    # extract repo/package name from 'path'
    IFS='# ' read -r path pkg \
        <<< $(echo "$path" | sed -E 's|^(.*)?/([^/]+)/?$|\1# \2|')
    pkg=$(echo "$pkg" | sed -E 's|\.git$||')

    [ -z "$pkg" ] && return 1

    # cleanup redundant parts
    [ "${path::1}" == "/" ] && path="${path:1}"
    [ "${host::4}" == "git." ] && host="${host:4}"

    # reconstruct path that smog should use for local directory path
    [ -n "$path" ] && path="$host/$path/$pkg" || path="$host/$pkg"
}


check_remote_refs() {
    local target data flags plural
    [ -z ${OPTS[$mode]} ] && target=available || target=matching

    if [ $mode == tag ]; then
        flags="-t --sort=version:refname $url ${OPTS[tag]-}"
        plural=tags
    else
        flags="-h $url ${OPTS[branch]-}"
        plural=branches
    fi

    echo "checking $target $plural..."

	data=$( $GIT ls-remote $flags )
    test $? || abort

    while read -r sha refname; do
        [ "${refname: -3}" == ^{} ] && continue  # TODO not sure what to do with those
        ref=$(echo "$refname" | cut -s -d/ -f3)
        # make sure 'ref' holds last one
        [ -n "$ref" ] && refs[$ref]=$sha && refsarr+=($ref)
    done <<< $data

    echo "found ${#refs[@]} $plural"
}


check_refs() {
    # pkg will be added either in 'tag' or 'branch' mode
    # check for user preference, if none try 'tag' first
    mode=${OPTS[mode]-tag}
    [ ${OPTS[branch]} ] && mode=branch

    if [ $mode == tag ]; then
        check_remote_refs

        if [ ${#refs[@]} -eq 0 ]; then
            # abort if user asked for tags
            [ ${OPTS[mode]} ] || [ ${OPTS[tag]} ] && abort
			check_proceed "try branches?"
			ref=
			mode="branch"
        fi

    fi

    if [ $mode == branch ]; then
        check_remote_refs

        [ ${#refs[@]} -eq 0 ] && abort

        # mark 'master' or 'main' as preferred branch
        ref=
        [ ${refs[main]} ] && ref=main
        [ ${refs[master]} ] && ref=master
    fi
}


# Check if URL is valid and show available refs (tags or branches).
check() {
    local url pkg path

    url_parse $1 || abort "failed to parse the URL"

    echo "********************************************************************"
    echo -e "    package: $BOLD$pkg$CLEAR"
    echo "        URL: $url"
    echo "********************************************************************"

    local mode flags

    [ ${OPTS[mode]} ] && mode=${OPTS[mode]} || mode=tag
    [ $mode == "tag" ] && flags="-t" || flags="-h"

    echo "checking avilable ${mode}s [$flags]..."

    local ref sha

    while read -r sha ref; do
        ref=$(echo "$ref" | cut -d/ -f3)
        printf "  %-25s %s\n" "$ref" "$sha"
    done <<< $( $GIT ls-remote $flags "$url" )

    echo ""
}

# Add a repository, i.e. check for available refs (tags or branches),
# clone the repository and create a metadata file.
add() {

	opts_show

    local pkg path url="$1"
    local -A md

    url_parse "$url" || abort "failed to parse the URL"

    echo
    echo "    package: $pkg"
    echo "        URL: $url"
    echo "       path: $PKG/$path/"
	echo

    check_proceed

    # TODO check for blanks in url/path
    md[url]=$url
    md[path]=$path

    # if URL is already used for another package
    # throw a warning
    local used=$(grep -rlE "^url: ${url}$" "$MDD/")
    if [ -n "$used" ]; then
        echo "warning: URL already used by package '`basename $used`'"
        check_proceed
    fi

    # check that pkg name is not already used
    # it's ok to have two git repositories with the same name
    # but in our metadata each package name should be unique.
	decho "check pkg"
    while md_exists "$pkg"; do
        echo "package name already used"
        echo "you can use an alternative name"
        read -p "use name: " pkg
		[ -n "$pkg" ] || abort
		# update path with new name
        path=$(echo "$path" | sed -E s|([^/])+$|"$pkg"|)
    done

	decho "ok"

	# check available tags/branches and which
	# ref we will use to clone the repo

    local -A refs
	local -a refsarr
    local mode ref refname sha

	check_refs

    #decho "********************"
    #for t in 
    #decho "********************"

    # ask to confirm selected tag/branch (if any)
    if [ -n "$ref" ] && [ "$ref" != "${OPTS[$mode]}" ]; then
        read -p "use $mode [$ref]? [y/N]: "
        [ "$REPLY" == "y" ] || [ "$REPLY" == "yes" ] || ref=
    fi

    # ask to choose tag/branch if nothing is selected
    if [ -z "$ref" ]; then
        echo "choose $mode to clone"
        select ref in "${refsarr[@]}"; do break; done
    fi
        
    [ -n "$ref" ] && [ ${refs[$ref]+_} ] || abort

    md[mode]=$mode
    md[ref]=$ref
    md[sha]=${refs[$ref]}

    echo -e "${BOLD}selected $mode [$ref] [${refs[$ref]}]${CLEAR}"

	# clone the repository into the package's path
	mkdir -vp "$PKG/$path" || abort
	cd "$PKG/$path"
	echo -en "$GREY"

	$GIT clone --depth=1 -c advice.detachedHead=false -b $ref "$url" .
	test $? || { rm -rf "$PKG/$path"; abort; }

	$GIT checkout -b "${MASTERBRANCH}" || { rm -rf "$PKG/$path"; abort; }
	echo -en "$CLEAR"

    md_dump $pkg
    echo -e "${BOLD}package '$pkg' created${CLEAR}"
}

# check for available updates - for all packages, if no args
# or for a specific package, if package name is provided
sync() {

    if [ ! ${OPTS[no_header]} ]; then
        printf "************************* ******************** **************************************************\n"
        printf "%-25s %-20s %s\n" "package" "current head" "status"
        printf "************************* ******************** **************************************************\n"
    fi

    if [ -n "$1" ]; then
        sync_pkg $1
    else
        md_list | xargs -P ${NTHREADS} -I {} $0 sync {} -n
        wait
        echo ""
        echo "syncing complete!"
    fi
}

sync_pkg() {

    local -A md refs
    local color msg

    # TODO: update last commit hash
    # cmd: git log pkgdata[ref] -1 --pretty=format:%H
    md_load $1 || abort "package '$1' does not exist"
    [ "${md[mode]}" == tag ] && sync_pkg_tag $1 || sync_pkg_branch $1
    printf "%b%-25s %-20s %-50s%b\n" $color $1 "${md[mode]} '${md[ref]}'" "$msg" $CLEAR
}

sync_pkg_branch() {

    read -r sha _ <<< $($GIT ls-remote -h "${md[url]}" refs/heads/"${md[ref]}")

    if [ "${#sha}" -ne 40 ]; then
        color=$RED
        msg="error: ref '${md[ref]}' not found"
    elif [ "$sha" == "${md[sha]}" ]; then
        color=$GREY
        msg="up-to-date"
    else
        color=$BOLD
        msg="new commits(s)"
    fi
}

sync_pkg_tag() {

    local -i num=-1
    local tag

    while read -r tag; do
        # seems like a git bug, avoid
        [ "${tag: -3}" == "^{}" ] && continue

        if [ $num -ge 0 ]; then
            # optinally only grab tags matching pattern
            if [ ${md[tag_pattern]+_} ]; then
                grep -qP "${md[tag_pattern]}" || continue
            fi
            ((num++))
            refs[$tag]=
            ref=$tag
        elif [ "$tag" == "${md[ref]}" ]; then
            num=0
        fi
    done <<< $( $GIT ls-remote -t --sort=version:refname ${md[url]} | cut -d/ -f3 )

    case $num in
        -1 ) color=$RED; msg="error: tag '${md[ref]}' not found" ;;
        0 ) color=$GREY; msg="up-to-date" ;;
        1 ) color=$BOLD; msg="new tag '$ref'" ;;
        * ) color=$BOLD; msg="$num new tags, last: '$ref'" ;;
    esac
}

# scan for binaries and executables in package repository
# this command is useful after you've build a package
# TODO: poorly tested and probably very buggy
reflect() {
    local -A md
    md_exists "$1" || abort "package '$1' does not exist"
    md_load "$1"

    local dir="${md[path]}"
    # if a build directory is specified, only scan that
    if [ ${OPTS[root]} ]; then
        [ "${OPTS[root]: -1}" == "/" ] && OPTS[root]="${OPTS[root]::-1}"
        dir+="/${OPTS[root]}"
        if [ ! ${md[builddir]+_} ] || [ "${md[builddir]}" != "${OPTS[root]}" ]; then
            md[builddir]="${OPTS[root]}"
            [ ! ${OPTS[debug]} ] && md_dump "$1"
        fi
    elif [ ${md[builddir]+_} ]; then
        dir+="/${md[builddir]}"
    fi
    dir="$PKG/$dir"

    [ -d "$dir" ] || abort "directory '$dir' does not exist"
    [ -L "$dir" ] && abort "directory '$dir' is a symlink"

    local -A bins libs
    echo "scanning directory '$dir'..."
    reflect_dir "$dir"
    echo "detected ${#bins[@]} executables and ${#libs[@]} libraries"
    # don't continue if nothing detected
    [ ${#bins[@]} -eq 0 ] && [ ${#libs[@]} -eq 0 ] && return

    # show lists
    local key
    echo ""
    [ ${#bins[@]} -ne 0 ] && echo "executables:"
    for key in ${!bins[@]}; do echo " - $key"; done

    [ ${#libs[@]} -ne 0 ] && echo "libraries:"
    for key in ${!libs[@]}; do echo " - $key"; done

    read -n 1 -p "create and update links? [y/N]: "
    echo ""
    [ "$REPLY" == "y" ] || return

    if [ ${#bins[@]} -gt 1 ] || [ ${#libs[@]} -gt 1 ]; then
        read -n 1 -p "use all executables or edit the list? [a/e]: "
        echo ""
        if [ "$REPLY" == "e" ]; then
            edit_list || abort
        elif [ "$REPLY" != "a" ]; then
            return
        fi
    fi

    local target
    local -i n=${#dir}
    local -i removed=0 kept=0 added=0 libs_added=0

    echo "updating linkes ..."

    # the two directories for symlinks should exist
    [ -d "$BIN" ] || abort "directory [$BIN] does not exist"
    [ -d "$LIB" ] || abort "directory [$LIB] does not exist"

    # update links to executables
    for key in $(ls $BIN); do
        target=$(readlink $BIN/$key)
        [ -z "$target" ] && continue
        [ ${target::$n} != $dir ] && continue

        if [ ${bins[$target]+_} ]; then
            printf " %-20s %20s -> %s\n" "keep link" $key $target
            bins[$target]="$key"
            ((kept++))
        else
            printf " %-20s %20s -> %s\n" "remove dead link" $key $target
            [ ! ${OPTS[debug]} ] && unlink "$BIN/$key"
            ((removed++))
        fi
    done

    for target in ${!bins[@]}; do
        [ -n "${bins[$target]}" ] && continue
        key=$(basename $target)

        if [ -e "$BIN/$key" ]; then
            printf " %-20s %20s -> %s\n" "skip - name used" $key $target
        else
            printf " %-20s %20s -> %s\n" "create link" $key $target
            [ ! ${OPTS[debug]} ] && ln -s "$target" "$BIN/$key"
            bins[$target]="$key"
            ((added++))
        fi
    done

    # update links to shared libs
    # TODO: move to a function (almost exact same two loops)
    for key in $(ls $LIB); do
        target=$(readlink $LIB/$key)
        [ -z "$target" ] && continue
        [ ${target::$n} != $dir ] && continue

        if [ ${libs[$target]+_} ]; then
            printf " %-20s %20s -> %s\n" "keep link" $key $target
            [ ! ${OPTS[debug]} ] && libs[$target]="$key"
            ((kept++))
        else
            printf " %-20s %20s -> %s\n" "remove dead link" $key $target
            [ ! ${OPTS[debug]} ] && unlink "$LIB/$key"
            ((removed++))
        fi
    done

    for target in ${!libs[@]}; do
        [ -n "${libs[$target]}" ] && continue
        key=$(basename $target)

        if [ -e "$LIB/$key" ]; then
            printf " %-20s %20s -> %s\n" "skip - name used" $key $target
        else
            printf " %-20s %20s -> %s\n" "create link" $key $target
            [ ! ${OPTS[debug]} ] && ln -s "$target" "$LIB/$key"
            libs[$target]="$key"
            ((added++))
            ((libs_added++))
        fi
    done
    
    # report results
    echo "created $added, kept $kept, removed $removed links"
    [ $libs_added -ne 0 ] && echo "run 'sudo ldconfig' to update cache"

    # save metadata
    if [ ${OPTS[debug]} ]; then
        echo "in debug mode: nothing actually changed"
    elif [ $added -ne 0 ] || [ $removed -ne 0 ]; then
        md_dump_links "$1"
        echo "updated metadata of package '$1'"
    fi
}

# scan for executables in directory (arg).
# the full path of executables is added either
# to the AA 'bins' (if it's a binary or shell script) or
# the AA 'libs' (if it's a shared library).
#
# if the 'recursive' option is set, runs recursively
# in subdirectories.
reflect_dir() {
    local f p t
    for f in $(ls $1); do
        p="$1/$f"
        [ -L "$p" ] && continue
        [ -d "$p" ] && [ ${OPTS[recursive]} ] && reflect_dir "$p" && continue
        [ -x "$p" ] || continue

        t=$(file -b --mime-type "$p" | sed -E 's|.*-([a-z]+)$|\1|')
        case "$t" in
            shellscript | executable ) bins[$p]='' ;;
            sharedlib )   libs[$p]='' ;;
        esac
    done
}

edit_lists() {
    echo "'${FUNCNAME[0]}' not implemented yet"
    return

    # wip
    local f
    echo -e ":$PINK"
    for f in "${bins[@]}"; do echo " - $f"; done;
    echo -e "$CLEAR"

    echo ""
    echo "you can choose to use all, none or edit the list"
    read -p "[a]ll, [e]edit, [N]othing: "

    if [ "${REPLY::1}" == "a" ]; then
        ${md[bins]}=bins
    elif [ "${REPLY::1}" == "e" ]; then
        local tmpf="_tmp_smog_$1_bins.txt"
        local ok
        echo ${bins[@]} | tr ' ' '\n' > $tmpf
        $EDITOR $tmpf
        unset bins
        readarray -t bins <<< $(cat $tmpf)
        rm $tmpf
        ${md[bins]}=bins
    else
        echo "stopping"
        return
    fi
}

# updates a package repository:
# - in branch mode: just update to the latest commits
# - in tag mode: fetch and switch to the newer tag
# if the 'force' option is set, will try to merge any
# local changes before merging.
update() {

    local -A md
    md_load ${1:?missing pkg} || abort "no such package '$1'"

    local color msg ref sha
    local -A refs

    echo "checking for updates..."

    if [ "${md[mode]}" == branch ]; then
        sync_pkg_branch $1
        ref="${md[ref]}"
    elif [ "${md[mode]}" == tag ]; then
        sync_pkg_tag $1
    else
        abort "invalid mode '${md[mode]}'"
    fi

    # little hack, since we try to reuse the sync_* functions
    case "$color" in
        "$GREY" ) echo "package is up-to-date"; return ;;
        "$BOLD" ) ;;
        * ) abort $msg ;;
    esac

    echo "[$msg]"

    if [ "${md[mode]}" == tag ]; then
        if [ ${#refs} -eq 1 ]; then
            echo "new tag '$ref' available"
        else
            echo "${#refs} tags available, last: '$ref'"
            # if the 'force' option is set, just use
            # 'ref' which is likely the tag we want
            if [ ! ${OPTS[force]} ]; then
                read -n 1 -p "update to [$ref]? [y/N]: "
                [ "$REPLY" == "y" ] || ref=

                [ -z "$ref" ] && select ref in ${!refs[@]}; do break; done
            fi
        fi
        [ -n "$ref" ] && [ ${refs[$ref]+_} ] || abort
    else
        echo "new commit(s) on branch ${md[ref]}"
    fi

    local cwd=`pwd`
    cd "${PKG}/${md[path]}"
    $GIT checkout -q "$MASTERBRANCH" || abort

    # check for local changes
    echo "checking for local changes on '$MASTERBRANCH'..."
    if [ -n "$($GIT status -s)" ]; then
        # unless forced, abort if there are unstaged changes
        [ ! ${OPTS[force]} ] && abort "you have unstaged or uncommited changes"
        echo "creating an autocommit..."
        echo -en "$GREY"
        $GIT add . || abort
        $GIT commit -m "autocommit by $NAME" || abort
        echo -en "$CLEAR"
    else
        echo "clean branch"
    fi

    echo -en "$GREY"
    if [ "${md[mode]}" == tag ]; then
        $GIT fetch origin tag "$ref" || abort
        md[ref]="$ref"
    else 
        $GIT fetch origin "$ref" || abort
        md[sha]="$sha"
    fi

    $GIT merge -m "automerge by $NAME" "$ref" || abort
    echo -en "$CLEAR"
    cd $cwd

    md_dump $1

    if [ "${md[mode]}" == tag ]; then
        echo -e "${BOLD}updated to tag '$ref'${CLEAR}"
    else
        echo -e "${BOLD}updated to branch '$ref' [$sha]${CLEAR}"
    fi
}

# ---- main routine ---- #

# figure out home directory and load config
[ -L "$0" ] && confp=$(dirname $(readlink $0))/config.sh || confp=$(dirname $0)/config.sh
. $confp || abort "can't load '$confp'"
decho "loaded config [$confp]"

declare CMD ARG1 ARG2
declare -A OPTS

CMD=$1

case $CMD in
    add | check )
        [ -z $2 ] && abort "missing <URL>"
        [ "${2:0:1}" == "-" ] && abort "invalid <URL>"
        ARG1=$2
        shift 2 ;;
    set )
        [ -z $2 ] && abort "missing <PKG>"
        [ -z "$3" ] && abort "missing <KEY>"
        ARG1=$2
        ARG2=$3
        shift 3 ;;
    remove | show | path | update | reflect )
        [ -z $2 ] && abort "missing <PKG>"
        [ "${2:0:1}" == "-" ] && abort "invalid <PKG>"
        ARG1=$2
        shift 2 ;;
    sync )
        [ -n "$2" ] && [ "${2:0:1}" != "-" ] && { ARG1=$2; shift 2; } || shift 1 ;;
    list )
        shift 1 ;;
    help | -h | --help )
        usage
        exit 0 ;;
    version )
        version
        exit 0 ;;
    * )
        [ -z $CMD ] && abort "missing command"
        abort "invalid command '$CMD'" ;;
esac

while getopts 'vdtbnrfuR:T:B:' opt; do
    case $opt in
        v ) OPTS[verbose]=true ;;
        d ) OPTS[debug]=true ;;
        t ) OPTS[mode]=tag ;;
        b ) OPTS[mode]=branch ;;
        n ) OPTS[no_header]=true ;;
        r ) OPTS[recursive]=true ;;
        f ) OPTS[force]=true ;;
        u ) OPTS[url]=true ;;
        R ) OPTS[root]="$OPTARG" ;;
		T ) OPTS[tag]="$OPTARG" ;;
		B ) OPTS[branch]="$OPTARG" ;;
        ? ) abort ;;
    esac
done

$CMD $ARG1 $ARG2

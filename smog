#!/bin/bash

NAME=$(basename $0)
VERSION='0.0.1'

version() {
    echo "${NAME} v${VERSION}"
}

usage() {
    echo "
Usage: ${NAME} COMMAND [ARG] [OPTION...]

Commands:
    add <URL>     Clone and create new package from URL (expectedly
                  pointing to a git-repository). See more in 'Modes'.
    remove <PKG>  Remove PKG and all of its files.
    show <PKG>    Show metadata of PKG.
    path <PKG>    Print absolure path of PKG directory.
    reflect <PKG> Scan for executables in repository and create
                  symlinks.
    update <PKG>  Update package PKG, see 'Modes' for details.

    sync [<PKG>]  Sync package PKG (or all packages with no argument),
                  i.e. check for available updates.

    list          List packages.

    set <PKG> KEY[=VAL]
                  Set metadata value of KEY to VAL (without VAL,
                  show current value).

Options:
    options for 'add':
        -t        Add package in tag-mode
        -b        Add package in branch-mode
        -u        Force using URL as is

    options for 'add' and 'reflect':
        -d        Dry-run, don't download or create files

    options for 'reflect':
        -r <DIR>  Use subdirectory DIR instead of root directory
        -R        Scan directories recursively, not just root directory

    options for 'update':
        -f        Don't stop on uncommitted changes and don't ask to
                  select tag if more than one tag are available.

Modes:
    Packages are added and updated in one of the two modes:

    tag-mode      Local repository is cloned using a tag reference.
                  In this mode, when you update a package, we search
                  for a tag that is more recent than the current one,
                  and merge the local working branch.

                  When the attribute 'tag_pattern' is set, only tags
                  matching this pattern are considered.

    branch-mode   Local repository is cloned using a branch reference
                  (often master/main). Package is updated by merging
                  last commits into the local working branch.

    The \"local working branch\" is created when a repository is cloned,
    (useful if you like to mess with the source code). The name of this
    branch is defined in the config file.
    "
}


# ----- helper functions ----- #

# Exit program with optional error message
abort() {
    [ -n "$1" ] && echo "$1" >&2
    exit 1
}

# Ask user and read yes/no answer.
# Default answer is always 'no'.
ask() {
    read -p "${1:-proceed?} [y/N]: "
    [ "$REPLY" == y ] || [ "$REPLY" == yes ]
}

# -------- command functions  -------- #
# prefixed with '_' to avoid collision
# or confusion with bash commands.

# List all packages. Print name, current head and URL.
_list() {
    local pkg
    local -A md

    if [ ! ${OPTS[no_header]} ]; then
        printf "****************************** ******************** "
        printf "**************************************************\n"
        printf "%-30s %-20s %-50s\n" "package" "current head" "url"
        printf "****************************** ******************** "
        printf "**************************************************\n"
    fi

    for pkg in $(md_list); do
        md=()
        md_load "$pkg"
        printf "%-30s %-20s %-50s\n" "$pkg" "${md[mode]} '${md[ref]}'" "${md[url]}"
    done
}

# Show all metadata fields of package
_show() {
    local -A md
    local key

    md_load "$1" || abort "package '$1' does not exist"

    if [ ! ${OPTS[no_header]} ]; then
        printf "****************************** **************************************************\n"
        printf "package:                       %b%s%b\n" "$BOLD" "$1" "$CLEAR"
        printf "****************************** **************************************************\n"
    fi

    for key in ${!md[@]}; do printf "%-30s " "$key"; echo ${md[$key]}; done

    [ -f "$MDD/$1.bins" ] && printf "%-30s " "bins" && wc -l < "$MDD/$1.bins"
    [ -f "$MDD/$1.libs" ] && printf "%-30s " "libs" && wc -l < "$MDD/$1.libs"
}

# Print absolute path of package. Useful to quickly
# change directory. E.g., run "cd `smog path PKG`".
_path() {
    md_exists "$1" || abort "package '$1' does not exist"
    grep '^path: ' "$MDD/$1" | cut -d' ' -f2-
}

# Remove package. I.e. remove git repository, metadata and
# symbolic links (if any).
_remove() {
    md_exists "$1" || abort "package '$1' does not exist"
    
    local p=$(path "$1")
    [ -d "$p" ] || abort "invalid path: '$p'"

	echo "warning: any local changes will be permanently lost"
    ask "remove '$1'?" || exit

    if md_has_links "$1"; then
        local -A bins libs
        md_load_links "$1"
        echo "cleaning up symlinks.."
        if [ ${#bins[@]} -ne 0 ]; then
            links_remove bins "$BIN" "$p"
            links_clean bins "$BIN" "$p"
        fi
        if [ ${#libs[@]} -ne 0 ]; then
            links_remove libs "$LIB" "$p"
            links_clean libs "$LIB" "$p"
        fi
    fi

    rm -rf "$p" || abort
	echo "removed repository '$p'"

    md_remove "$1"
    echo -e "${BOLD}package '$1' removed${CLEAR}"
}


# Check the URL is valid and check available git refs (tags/branches).
# This is like 'add' but without creating a local package.
_check() {
    local pkg path url="$1"

    url_parse "$url" || abort "failed to parse the URL"

    printf "\n"
    printf "%-10s: %s\n" "package" "$pkg"
    printf "%-10s: %s\n" "url" "$url"
    printf "%-10s: %s\n" "path" "$path"
    printf "\n"

    local -A refs
	local -a refsarr
    local mode ref refname sha

	check_refs || abort

    for r in "${refsarr[@]}"; do echo "  * $r"; done
}

# Add a repository, i.e. check for available refs (tags or branches),
# clone the repository and create a metadata file.
_add() {

    local pkg path url="$1"

    url_parse "$url" || abort "failed to parse the URL"

    printf "\n"
    printf "%-10s: %s\n" "package" "$pkg"
    printf "%-10s: %s\n" "url" "$url"
    printf "%-10s: %s\n" "path" "$path"
    printf "\n"

    ask 'proceed?' || exit

    local -A md
    md[url]=$url

    # Warn if URL used for another package
    local used=$(grep -rlE "^url: ${url}$" "$MDD/")
    if [ -n "$used" ]; then
        echo "warning: URL already used by package '`basename $used`'"
        ask 'continue anyway?' || exit
    fi

    # Check that pkg name is not already used. It's OK to
    # have two git repositories with the same name, but in
    # our metadata each package name should be unique.
    while md_exists "$pkg"; do
        echo "package name already used"
        echo "you can use an alternative name"
        read -p "use name: " pkg
		[ -n "$pkg" ] || abort
		# update path with new name
        path=$(echo "$path" | sed -E s|([^/])+$|"$pkg"|)
    done

    md[path]="$PKG/$path"

	# check available tags/branches and which
	# ref we will use to clone the repo
    local -A refs
	local -a refsarr
    local mode ref refname sha

	check_refs

    # ask to confirm selected tag/branch (if any)
    if [ -n "$ref" ] && [ "$ref" != "${OPTS[$mode]}" ]; then
        ask "use $mode [$ref]?" || ref=
    fi

    # ask to choose tag/branch if nothing is selected
    if [ -z "$ref" ]; then
        echo "choose $mode to clone"
        select ref in "${refsarr[@]}"; do break; done
    fi
        
    [ -n "$ref" ] && [ ${refs[$ref]+_} ] || abort

    md[mode]=$mode
    md[ref]=$ref
    # SHA only relevant for branches
    [ "$mode" == branch ] && md[sha]=${refs[$ref]}

    echo -e "${BOLD}selected $mode [$ref] ${CLEAR}"

	# Clone repo into the package's path
	mkdir -vp "$PKG/$path" || abort
	cd "$PKG/$path"

	echo -en "$GREY"
	$GIT clone --depth=1 -c advice.detachedHead=false -b "$ref" "$url" .
	[ $? -ne 0 ] && rm -rf "$PKG/$path" && abort

	$GIT checkout -b "${MASTERBRANCH}" 
	[ $? -ne 0 ] && rm -rf "$PKG/$path" && abort
	echo -en "$CLEAR"

    md_dump "$pkg"
    echo -e "${BOLD}package '$pkg' created${CLEAR}"
}

# Sync package(s) with upstream repository. With no argument, all packages
# are synced, otherwise only given packages is synced.
# When all packages are synced, this function calls itself concurrently.
_sync() {

    if [ ! ${OPTS[no_header]} ]; then
        printf "****************************** ******************** "
        printf "**************************************************\n"
        printf "%-30s %-20s %s\n" "package" "current head" "status"
        printf "****************************** ******************** "
        printf "**************************************************\n"
    fi

    # Sync single package and exit
    [ -n "$1" ] && sync_pkg "$1" && return

    # Sync all packages - run 'smog PKG -n' for each package
    # (-n will prevent printing header each time)
    md_list | xargs -P ${NPROCS} -I {} $0 sync {} -n
    wait
    printf "\nsyncing complete!\n"
}

# updates a package repository:
# - in branch mode: just update to the latest commits
# - in tag mode: fetch and switch to the newer tag
# if the 'force' option is set, will try to merge any
# local changes before merging.
_update() {

    local -A md
    md_load "$1" || abort "package '$1' does not exist"

    local status ref
    local -a refsarr
    local -A refs

    echo -n "checking for updates.. "

    if [ "${md[mode]}" == branch ]; then
        sync_branch "${md[url]}" "${md[ref]}" "${md[sha]}"
    elif [ "${md[mode]}" == tag ]; then
        sync_tag "${md[url]}" "${md[ref]}" "${md[tag_pattern]-}"
    else
        abort "invalid mode '${md[mode]}'"
    fi

    case $? in 
        0 ) echo "package is up-to-date"; return ;;
        1 | 2 ) echo -e "${BOLD}${status}${CLEAR}" ;;
        * ) abort "$status" ;;
    esac

    echo "ref = [$ref]"

    # If we get here, updates are available.
    # For branch mode, we just need to update local branch
    # For tag mode, multiple new tags ('releases') might
    # be avaiable, so we ask user which to choose.
    if [ "${md[mode]}" == tag ]; then
        check_tags || abort 'terminated'
    fi

    # Enter package directory
    echo "entering directory '${md[path]}'"
    cd "${md[path]}" || abort
    $GIT checkout -q "$MASTERBRANCH" || abort

    # Before fetching remote changes, make sure our
    # local branch does not gave uncommitted commits.
    echo -n "checking local changes in '$MASTERBRANCH'.. "
    if [ -z "$($GIT status -s)" ]; then
        echo "OK: clean branch"
    else
        echo
        echo "you have unstaged or uncommited changes"
        ask "create autocommit?" || abort
        echo -en "$GREY"
        # TODO: something better than 'add .'
        $GIT add . || abort
        $GIT commit -m "autocommit by $NAME" || abort
        echo -en "$CLEAR"
    fi

    # Fetch remote changes
    echo -en "$GREY"
    if [ "${md[mode]}" == tag ]; then
        $GIT fetch origin tag "$ref" || abort
        $GIT merge -m "automerge by $NAME" "$ref" || abort
        md[ref]="$ref"
    else 
        $GIT fetch origin "$ref" || abort
        md[sha]=$( $GIT log origin/"${md[ref]}" -1 --pretty=format:%H )
        $GIT merge -m "automerge by $NAME" origin/"$ref" || abort
    fi
    echo -en "$CLEAR"

    md_dump "$1"

    echo -en "${BOLD}package '$1' updated to "
    if [ "${md[mode]}" == tag ]; then
        echo "tag '$ref'"
    else
        echo "remote branch '$ref' [$sha]"
    fi
    echo -en "$CLEAR"
}

# Scan for executables and sharedlibs in a the root directory
# of a package and create symlinks in the Smog directories
# '$BIN' and '$LIB' respectively.
# In recursive mode, scan the entire filetree of a package.
_link() {
    local -A md
    md_load "$1" || abort "package '$1' does not exist"

    # Root directory of the package.
    local root="${md[path]}"

    # User flag '-R' or metadata field 'builddir' tell
    # us to scan only a subdirectory.
    local dir
    if [ ${OPTS[root]+_} ]; then
        dir="${OPTS[root]}"
    elif [ ${md[builddir]+_} ]; then
        dir="${md[builddir]}"
    fi
    [ "${dir: -1}" == / ] && dir="${dir::-1}" # strip trailing '/'

    # sanity check
    [ -d "$root/$dir" ] || abort "path '$root/$dir' does not exist"
    [ -L "$root/$dir" ] && abort "path '$root/$dir' is a symlink"


    # --- Scan for targets --- #

    # Each of these two AA's contains the target file as key
    # and the linkname as value. Target file is the relative
    # path of the file in the 'root' directory.
    local -A bins libs

    echo "scanning '$root/$dir'"
    links_scan bins libs "$root" "$dir" ${OPTS[recursive]-}
    echo "detected ${#bins[@]} executables and ${#libs[@]} libraries"

    # if nothing detected, we're done here
    [ ${#bins[@]} -eq 0 ] && [ ${#libs[@]} -eq 0 ] && exit

    # If package already has links, mark our action as 'update'.
    # This means we can expect that some links already exists
    # and we will check for dead links.
    local update
    md_has_links "$1" && update=update
    ask "${update-create} symlinks?" || exit

    # It's possible that we detect a lot of executables that
    # (e.g. build or test scripts) that would create garbage
    # symlinks, so give user option to filter the lists.
    if [ ${#bins[@]} -gt 1 ] || [ ${#libs[@]} -gt 1 ]; then
        ask "edit list of links first?" && links_edit "$root" bins libs
    fi

    # TODO: for debugging, remove ========>
    local k
    echo -en "$CYAN"
    for k in "${!bins[@]}"; do printf "%-20s -> %s\n" "${bins[$k]}" "$k"; done

    echo -en "$PINK"
    for k in "${!libs[@]}"; do printf "%-20s -> %s\n" "${libs[$k]}" "$k"; done

    echo -e "$CLEAR"
    ask 'continue ?' || exit
    # ===================================>


    # --- Create links --- #
    local -i added=0 removed=0 conflicts=0 skipped=0

    printf "%b" $BOLD
    printf "%-15s %-20% %s\n" 'Action' 'Linkname' 'Target'
    printf "%b" $CLEAR
   
    # Clean up any dead links to 'root'
    if [ -n "$update" ]; then
        links_clean bins "$BIN" "$root"
        links_clean libs "$LIB" "$root"
    fi

    # Create links
    [ ${#bins[@]} -ne 0 ] && links_create bins "$BIN" "$p" && md_dump_links "$1" bins
    [ ${#libs[@]} -ne 0 ] && links_create libs "$LIB" "$p" && md_dump_links "$1" libs
    
    # Report results
    echo -e $BOLD
    echo -n "$added created, $skipped skipped, "
    echo "$removed removed, $conflicts conflicts."
    echo -en $CLEAR

    # TODO: maybe they know, so no need
    [ ${#libs[@]} -ne 0 ] && echo "you can run 'sudo ldconfig' to update cache"

    # Update metadata
    md_dump_links "$1" bins
    md_dump_links "$1" libs
}

# ---- main routine ---- #

# DEBUG
#echo -en "\033[90m"

# figure out home directory and load config
[ -L "$0" ] && confp=$(dirname $(readlink $0))/config.sh || confp=$(dirname $0)/config.sh
. $confp || abort "can't load '$confp'"

# TODO: remove cd && use $SMOG_PATH
cd `dirname $confp`

declare LIBS
LIBS=$(ls util) || abort

while read -r lib; do
    . util/$lib || abort
    #echo "loaded '$lib'"
done <<< $LIBS
unset LIBS confp

declare CMD ARG1 ARG2
declare -A OPTS

CMD=$1

case $CMD in
    add | check )
        [ -z $2 ] && abort "missing <URL>"
        [ "${2:0:1}" == "-" ] && abort "invalid <URL>"
        ARG1=$2
        shift 2 ;;
    set )
        [ -z $2 ] && abort "missing <PKG>"
        [ -z "$3" ] && abort "missing <KEY>"
        ARG1=$2
        ARG2=$3
        shift 3 ;;
    remove | show | path | update | link )
        [ -z $2 ] && abort "missing <PKG>"
        [ "${2:0:1}" == "-" ] && abort "invalid <PKG>"
        ARG1=$2
        shift 2 ;;
    sync )
        [ -n "$2" ] && [ "${2:0:1}" != "-" ] && { ARG1=$2; shift 2; } || shift 1 ;;
    list )
        shift 1 ;;
    help | -h | --help )
        usage
        exit 0 ;;
    version )
        version
        exit 0 ;;
    * )
        [ -z $CMD ] && abort "missing command"
        abort "invalid command '$CMD'" ;;
esac

while getopts 'vdtbnrfuR:T:B:' opt; do
    case $opt in
        v ) OPTS[verbose]=true ;;
        d ) OPTS[debug]=true ;;
        t ) OPTS[mode]=tag ;;
        b ) OPTS[mode]=branch ;;
        n ) OPTS[no_header]=true ;;
        r ) OPTS[recursive]=true ;;
        f ) OPTS[force]=true ;;
        u ) OPTS[url]=true ;;
        R ) OPTS[root]="$OPTARG" ;;
		T ) OPTS[tag]="$OPTARG" ;;
		B ) OPTS[branch]="$OPTARG" ;;
        ? ) abort ;;
    esac
done

#echo "CMD=[$CMD] - ARG1=[$ARG1] - ARG2=[$ARG2]"
#echo -en "\033[0m"

_$CMD $ARG1 $ARG2

#!/usr/bin/env bash

set -e 

readonly NAME=$(basename $0)
readonly VERSION='0.0.0'

_version() {
    echo "${NAME} v${VERSION}"
}

_usage() {
    echo "Usage: $NAME COMMAND [ARG] [OPTIONS]"
}

_help() {
    _usage
    cat << EOF

Commands:
    list          List all local packages
    add <URL>     Create new package from a git URL
    remove <PKG>  Remove PKG and all of its files
    show <PKG>    Show PKG metadata
    path <PKG>    Print absolute path of local repository
    sync [<PKG>]  Sync PKG (or *all* packages with no argument),
                  i.e. check for updates in the remote repository
    update <PKG>  Update package PKG, see 'Modes' for details.
    link <PKG>    Create symlinks for binaries and libs in the
                  local repostory
    unlink <PKG>  Remove and clean-up symlinks

    version       Print version and exit
    help          Print this message

Options:
    -t            Run in tag-mode (normally the default)
    -b            Run in branch-mode
    -f            Force (don't ask anything to confirm)
    -r            Run recursively in all subdirectories (for 'link')
    -m            When listing or syncing packages, show more details
                  and decoratations

    -T  <TAG>     Use tag TAG only (valid for 'add' and 'update')
    -B  <BRANCH>  Use branch BRANCH (valid for 'add' and 'update')
    -r  <dir>     Scan DIR instead of root directory of package (for 'link')

Modes:
    Smog links each local package to a remote git "ref", this is either
    a tag or branch, hence the two modes.

    * tag mode *
    A package is created by cloning a git tag. When updating, 
    Smog searches for a tag that is more recent than the local
    one and merges your local branch to the new tag.
    This is always the preferred mode.

    * Branch-mode *
    A package is created by cloning a git branch. When updating,
    Smog checks for new commits on the remote branch and merges
    those to your local branch.

    In both cases, Smog always creates a *local working branch*,
    which will contain your local changes, and the original branch
    or tag will be kept clean.
EOF
}


# ----- helper functions ----- #

# Exit program with optional error message
abort() {
    [ -n "$1" ] && echo "$1" >&2
    exit 1
}

# Ask user and read yes/no answer.
# Default answer is always 'no'.
ask() {
    read -p "${1:-proceed?} [y/N]: "
    [ "$REPLY" == y ] || [ "$REPLY" == yes ]
}

# -------- command functions  -------- #
# prefixed with '_' to avoid collision
# or confusion with bash commands.

# Decorated list of packages. Print name, current head and URL.
_listmore() {
    local pkg
    local -A md

    printf "%b%-30s %-20s %s%b\n" $BOLD "package" "remote ref" "url" $CLEAR

    for pkg in $(md_list); do
        md=()
        md_load "$pkg"
        printf "%-30s %b%6s%b %-13s %s\n" "$pkg" $GREY "${md[mode]}" $CLEAR \
            "${md[ref]}" "${md[url]}"
    done
}

# Raw list of packages
_list() {
    [ ${OPTS[more]+_} ] && _listmore || md_list
}

# Show decorated metadata of package
_showmore() {
    local -A md
    local key

    md_load "$1" || abort "package '$1' does not exist"

    printf "%b%-30s %s%b\n" "$BOLD" "package" "$1" "$CLEAR"

    for key in ${!md[@]}; do printf "%-30s " "$key"; echo ${md[$key]}; done

    # number of symlinks
    printf "%b" $GREY
    printf "%-30s %d bins and %d libs\n" "links" \
        $( cat "$ROOT/$MDD/$1"{.bin,.lib} 2> /dev/null | wc -l )
    printf "%b" $CLEAR
}

# Show raw metadata of package
_show() {
    [ ${OPTS[more]+_} ] && _showmore "$1" || cat "$ROOT/$MDD/$1"
}

# Print path of local repository. Useful to quickly
# change directory. E.g., run "cd `smog path PKG`".
_path() {
    md_exists "$1" || abort "package '$1' does not exist"
    echo -n "$ROOT/$PKG/"
    grep '^path: ' "$ROOT/$MDD/$1" | cut -d' ' -f2-
}

# Remove package, i.e. remove local repository, metadata file
# and symbolic links (if any).
_remove() {

    local -A md
    md_load "$1" || abort "package '$1' does not exist"
   
    local path="${md[path]}" 
    [ -d "$ROOT/$PKG/$path" ] || abort "invalid path '$path'"

    if [ ! ${OPTS[force]+_} ]; then
        echo "warning: any local changes will be permanently lost"
        ask "remove '$1'?" || exit
    fi

    if md_links_exist "$1"; then
        local -A bin lib
        echo "cleaning up symlinks.."

        if md_links_load "$1" bin; then
            links_remove bin "$ROOT/$BIN" "$ROOT/$PKG/$path"
            links_clean bin "$ROOT/$BIN" "$ROOT/$PKG/$path"
        fi

        if md_links_load "$1" lib; then
            links_remove lib "$ROOT/$LIB" "$path"
            links_clean lib "$ROOT/$LIB" "$path"
        fi

        md_links_remove "$1"
    fi

    rm -rf "$ROOT/$PKG/$path" || abort
	echo "removed repository '$path'"

    # remove empty parent directories
    while path=$( dirname "$path"); do
        [ -z "$path" ] || [ "$path" == "." ] && break
        [ $( ls -A "$ROOT/$PKG/$path" | wc -l ) -ne 0 ] && break
        rm -vd "$ROOT/$PKG/$path" || abort
    done

    md_remove "$1"
    echo -e "${BOLD}package '$1' removed${CLEAR}"
}


# Check the URL is valid and check available git refs (tags/branches).
# This is like 'add' but without creating a local package.
_check() {
    local pkg path url="$1"

    url_parse "$url" || abort "failed to parse the URL"

    printf "\n"
    printf "%-10s %s\n" "package:" "$pkg"
    printf "%-10s %s\n" "url:" "$url"
    printf "%-10s %s\n" "path:" "$path"
    printf "\n"

    local -A refs
	local -a refsarr
    local mode ref refname sha

	check_refs || abort

    for r in "${refsarr[@]}"; do echo "  * $r"; done
}

# Add a repository, i.e. check for available refs (tags or branches),
# then clone the repository and create metadata file.
_add() {

    local pkg path url="$1"

    url_parse "$url" || abort "failed to parse the URL"

    printf "\n"
    printf "%-10s %s\n" "package:" "$pkg"
    printf "%-10s %s\n" "url:" "$url"
    printf "%-10s %s\n" "path:" "$path"
    printf "\n"

    if [ ! ${OPTS[force]+_} ]; then
        ask 'proceed?' && echo || exit
    fi

    local -A md
    md[url]=$url

    # Warn if URL used for another package
    local used=$(grep -rlE "^url: ${url}$" "$ROOT/$MDD/")
    if [ -n "$used" ]; then
        echo "URL already used by package '`basename $used`'"
        # ask 'continue anyway?' || exit
        # TODO: need to handle conflicting paths
        abort
    fi

    # Check that pkg name is not already used. It's OK to
    # have two git repositories with the same name, but in
    # our metadata each package name should be unique.
    while md_exists "$pkg"; do
        echo -en "a package $BOLD'$pkg'$CLEAR already exists, "
        echo "you can use an alternative name"
        read -p "use name: " pkg
		[ -n "$pkg" ] || abort
        echo
    done

    md[path]="$path"

	# check available tags/branches and which
	# ref we will use to clone the repo
    local -A refs
	local -a refsarr
    local mode ref refname sha

	check_refs || abort

    # ask to confirm selected tag/branch (if any)
    if [ -n "$ref" ] && [ "$ref" != "${OPTS[$mode]}" ]; then
        ask "use $mode [$ref]?" || ref=
    fi

    # ask to choose tag/branch if nothing is selected
    # TODO: don't ask if 1 ref and user already declined
    if [ -z "$ref" ]; then
        echo "choose $mode to clone"
        select ref in "${refsarr[@]}"; do break; done
    fi
        
    [ -n "$ref" ] && [ ${refs[$ref]+_} ] || abort

    md[mode]=$mode
    md[ref]=$ref
    # SHA only relevant for branches
    [ "$mode" == branch ] && md[sha]=${refs[$ref]}

    echo
    echo -e "${BOLD}selected $mode [$ref] ${CLEAR}"

	# Clone repo into the package's path
	mkdir -vp "$ROOT/$PKG/$path" || abort
	cd "$ROOT/$PKG/$path"

	echo -en "$GREY"
	$GIT clone --depth=1 -c advice.detachedHead=false -b "$ref" "$url" "$ROOT/$PKG/$path"
	[ $? -ne 0 ] && rm -rf "$ROOT/$PKG/$path" && abort

	$GIT checkout -b "${LOCALBRANCH}" 
	[ $? -ne 0 ] && rm -rf "$ROOT/$PKG/$path" && abort
	echo -en "$CLEAR"

    md_dump "$pkg"
    echo -e "${BOLD}package '$pkg' created${CLEAR}"
}

# Sync package(s) with upstream repository. With no argument, all packages
# are synced, otherwise only given packages is synced.
# When all packages are synced, this function calls itself concurrently.
_sync() {

    if [ ${OPTS[more]+_} ] && [ ! ${OPTS[no_header]+_} ]; then
        printf "%b%-30s %-20s %s%b\n" $BOLD "package" "remote ref" "status" $CLEAR
    fi

    # Sync single package and exit
    [ -n "$1" ] && sync_pkg "$1" && return

    # Sync all packages - run 'smog PKG -n' for each package
    # (-n will prevent printing header each time)
    [ ${OPTS[more]+_} ] && flags="-nm" || flags="-n"
    md_list | xargs -P ${NPROCS} -I {} $0 sync "$flags" {}
    wait
    [ ${OPTS[more]+_} ] && printf "\nsyncing complete!\n"
}

# updates a package repository:
# - in branch mode: just update to the latest commits
# - in tag mode: fetch and switch to the newer tag
# if the 'force' option is set, will try to merge any
# local changes before merging.
_update() {
    local -A md
    md_load "$1" || abort "package '$1' does not exist"

    local status ref
    local -a refsarr
    local -A refs

    echo -n "checking for updates.. "

    if [ "${md[mode]}" == branch ]; then
        sync_branch "${md[url]}" "${md[ref]}" "${md[sha]}"
    elif [ "${md[mode]}" == tag ]; then
        sync_tag "${md[url]}" "${md[ref]}" "${md[tag_pattern]-}"
    else
        abort "invalid mode '${md[mode]}'"
    fi

    case $? in 
        0 ) echo "package is up-to-date"; return ;;
        1 | 2 ) echo -e "${BOLD}${status}${CLEAR}" ;;
        * ) abort "$status" ;;
    esac

    # If we get here, updates are available.
    # For branch mode, we just need to update local branch
    # For tag mode, multiple new tags ('releases') might
    # be avaiable, so we ask user which to choose.
    if [ "${md[mode]}" == tag ]; then
        check_tags || abort 'terminated'
    fi

    # Enter package directory
    echo "entering directory '${md[path]}'"
    cd "$ROOT/$PKG/${md[path]}" || abort
    $GIT checkout -q "$LOCALBRANCH" || abort

    # Before fetching remote changes, make sure our
    # local branch does not have uncommitted commits.
    echo -n "checking local changes in '$LOCALBRANCH'.. "
    if [ -z "$($GIT status -s)" ]; then
        echo "OK: clean branch"
    else
        echo
        echo "you have $($GIT status -s | wc -l) unstaged or uncommited changes"
        ask "create autocommit?" || abort
        echo -en "$GREY"
        # TODO: something better than 'add .'
        $GIT add . || abort
        $GIT commit -m "autocommit by $NAME" || abort
        echo -en "$CLEAR"
    fi

    # Fetch remote changes
    echo -en "$GREY"
    if [ "${md[mode]}" == tag ]; then
        $GIT fetch origin tag "$ref" || abort
        $GIT merge -m "automerge by $NAME" "$ref" || abort
        md[ref]="$ref"
    else 
        $GIT fetch origin "$ref" || abort
        md[sha]=$( $GIT log origin/"${md[ref]}" -1 --pretty=format:%H )
        $GIT merge -m "automerge by $NAME" origin/"$ref" || abort
    fi
    echo -en "$CLEAR"

    md_dump "$1"

    echo -en "${BOLD}package '$1' updated to "
    if [ "${md[mode]}" == tag ]; then
        echo "tag '$ref'"
    else
        echo "remote branch '$ref' [$sha]"
    fi
    echo -en "$CLEAR"
}

# Scan for executables and sharedlibs in a the root directory
# of a package and create symlinks in the Smog directories
# '$BIN' and '$LIB' respectively.
# In recursive mode, scan the entire filetree of a package.
_link() {
    local -A md
    md_load "$1" || abort "package '$1' does not exist"

    if [ -z "$BIN" ] && [ -z "$LIB" ]; then
        echo 'variables $BIN and $LIB not set in config'
        abort
    fi

    # --- Prepare --- #

    # Root directory of the package.
    local path="$ROOT/$PKG/${md[path]}"

    # User flag '-R' or metadata field 'builddir' tell
    # us to scan only a subdirectory.
    local dir
    if [ ${OPTS[root]+_} ]; then
        dir="${OPTS[root]}"
    elif [ ${md[builddir]+_} ]; then
        dir="${md[builddir]}"
    fi
    [ "${dir: -1}" == / ] && dir="${dir::-1}" # strip trailing '/'

    # sanity check
    [ -d "$path/$dir" ] || abort "path '$path/$dir' does not exist"
    [ -L "$path/$dir" ] && abort "path '$path/$dir' is a symlink"

    # Each of these two AA's shall contain target file as
    # key and linkname as value. Target file is the relative
    # path of the file in the 'root' directory.
    local -A bin lib

    # If package already has links, mark our action as 'update'.
    # This means we can expect that some links already exists
    # and we will check for dead links.
    local update recursive
    if md_links_exist "$1"; then
        update=update
        # Load existing links, otherwise we might try to
        # re-create the same link (e.g. with different linkname)
        [ -n "$BIN" ] && md_links_load "$1" bin
        [ -n "$LIB" ] && md_links_load "$1" lib
    fi

    # --- Scan for targets --- #

    echo "scanning '$path/$dir'"
    [ ${OPTS[recurse]+_} ] && recursive=r
    links_scan "$path" "$dir" $recursive
    echo "detected ${#bin[@]} executables and ${#lib[@]} libraries"

    # if nothing detected, we're done here
    [ ${#bin[@]} -eq 0 ] && [ ${#lib[@]} -eq 0 ] && exit

    # It's possible that we detect a lot of executables
    # (e.g. build or test scripts) that would create garbage
    # symlinks, so give user option to filter the lists.
    if [ ${#bin[@]} -gt 1 ] || [ ${#lib[@]} -gt 1 ]; then
        ask "open list in editor?" && links_edit "$path" bin lib
    fi

    ask "${update-create} symlinks?" || exit

    # --- Create links --- #

    local -i created=0 cleaned=0 conflicts=0 skipped=0

    printf "\n%b" $BOLD
    printf "%-25s %-25s %s\n" 'Action' 'Linkname' 'Target'
    printf "%b" $CLEAR

    # create links for executables
    if [ ${#bin[@]} -ne 0 ]; then
        if [ -z "$BIN" ]; then
            echo 'variable $BIN not set, skipping executable targets'
        else
            [ -d "$ROOT/$BIN" ] || abort "directory '$ROOT/$BIN' does not exist"
            [ -n "$update" ] && links_clean bin "$ROOT/$BIN" "$path"
            links_create bin "$ROOT/$BIN" "$path"
            md_links_dump "$1" bin > /dev/null
       fi
    fi

    # create links for sharedlibs
    if [ ${#lib[@]} -ne 0 ]; then
        if [ -z "$LIB" ]; then
            echo 'variable $LIB not set, skipping sharedlibs'
        else
            [ -d "$ROOT/$LIB" ] || abort "directory '$ROOT/$LIB' does not exist"
            [ -n "$update" ] && links_clean lib "$ROOT/$LIB" "$path"
            links_create lib "$ROOT/$LIB" "$path"
            md_links_dump "$1" lib > /dev/null
        fi
    fi
    
    # Report results
    echo -e $BOLD
    echo -n "$created created, $skipped skipped, "
    echo "$cleaned cleaned, $conflicts conflicts."
    echo -en $CLEAR
}

_unlink() {
    local -A md
    md_load "$1" || abort "package '$1' does not exist"
    md_links_exist "$1" || abort "package '$1' has no links"

    local path="$ROOT/$PKG/${md[path]}"
    local -A bin lib
    local -i removed=0 skipped=0 cleaned=0

    printf "\n%b" $BOLD
    printf "%-25s %-25s %s\n" 'Action' 'Linkname' 'Target'
    printf "%b" $CLEAR
   
    if [ -n "$BIN" ] && md_links_load "$1" bin; then
        links_remove bin "$ROOT/$BIN" "$path"
        links_clean bin "$ROOT/$BIN" "$path"
    fi

    if [ -n "$LIB" ] && md_links_load "$1" lib; then
        links_remove lib "$ROOT/$LIB" "$path"
        links_clean lib "$ROOT/$LIB" "$path"
    fi

    # Report results
    echo -e $BOLD
    echo "$removed removed, $cleaned cleaned, $skipped skipped."
    echo -en $CLEAR

    # TODO: don't remove if links were not removed
    md_links_remove "$1"
}


# ---- main routine ---- #

# reject to run as root user
if [ "$EUID" -eq 0 ] || [ "$(id -u 2>/dev/null)" -eq 0 ]; then
    abort "please don't run $NAME as root"
fi

# figure out home directory and import config
if [ -L "$0" ]; then
    confp=$(dirname $(readlink $0))/config
else
    confp=$(dirname $0)/config
fi

. $confp
unset confp

# import utils
for u in color md url git sync link; do
    . $ROOT/$SMOG/util/$u
done

# check for commands that need no further work 
case $1 in
    -h | --help | help ) _help && exit 0 ;;
    -v | --version | version ) _version && exit 0 ;;
    * ) [ -z "$1" ] && _usage && abort 'error: missing command' ;;
esac

declare -a ARGS
declare -A OPTS
declare CMD=$1
shift

# it would have been easier to use getopts, but I needed need more flexibility
# rules for parsing options and arguments:
#   - boolean options are lowercased and can be combined (e.g. '-ft')
#   - options with argument are uppercased, can be only combined as last option (e.g. '-fB master')
#   - anything else (at any position) is argument to CMD
declare opt arg buf

while [ $# -gt 0 ]; do

    # --- parse option --- #
    opt=
    arg=
    [ -z "$buf" ] && buf="$1"

    if [ "${buf::1}" == - ]; then
        opt="${buf:1:1}"
        if [ -n "${buf:2}" ]; then
            buf="-${buf:2}"
        else
            [ "$buf" == "${buf^^}" ] && shift && arg="$1"
            shift
            buf=
        fi
    else
        arg="$buf"
        buf=
        shift
    fi

    # --- handle option --- #
    [ -z "$opt" ] && ARGS+=($arg) && continue

    case $opt in
        t ) OPTS[mode]=tag ;;
        b ) OPTS[mode]=branch ;;
        n ) OPTS[no_header]= ;;
        r ) OPTS[recurse]= ;;
        f ) OPTS[force]= ;;
        m ) OPTS[more]= ;;
        T ) [ -n "$arg" ] && OPTS[tag]="$arg" ||    abort "option '-$opt' requires argument" ;;
        B ) [ -n "$arg" ] && OPTS[branch]="$arg" || abort "option '-$opt' requires argument" ;;
        R ) [ -n "$arg" ] && OPTS[root]="$arg" ||   abort "option '-$opt' requires argument" ;;
        * ) abort "invalid option '-$opt'"
    esac
done

unset opt arg buf

# check that command has required number of arguments
case $CMD in
    add | check )
        [ ${#ARGS[@]} -ne 1 ] && abort "$CMD: requires 1 argument <URL>" ;;
    remove | show | path | update | link | unlink )
        [ ${#ARGS[@]} -ne 1 ] && abort "$CMD: requires 1 argument <PKG>" ;;
    sync )
        [ ! ${#ARGS[@]} -le 1 ] && abort "$CMD: has optional argument <PKG>" ;;
    list )
        [ ${#ARGS[@]} -ne 0 ] && abort "$CMD: requires no argument" ;;
    set )
        [ ${#ARGS[@]} -ne 2 ] && abort "$CMD: requires 2 arguments <PKG> <KEY>" ;;
    * ) abort "invalid command '$CMD'" ;;
esac

# lock metadata
case $CMD in
    add | remove | update | link | unlink | set )
        md_lock && trap 'md_unlock' EXIT || abort "metadata locked" ;;
esac

_$CMD "${ARGS[@]}"

#!/bin/bash

NAME=$(basename $0)
VERSION='0.0.1'

version() {
    echo "${NAME} v${VERSION}"
}

usage() {
    echo "
Usage: ${NAME} COMMAND [ARG] [OPTION...]

Commands:
    add <URL>     Clone and create new package from URL (expectedly
                  pointing to a git-repository). See more in 'Modes'.
    remove <PKG>  Remove PKG and all of its files.
    show <PKG>    Show metadata of PKG.
    path <PKG>    Print absolure path of PKG directory.
    reflect <PKG> Scan for executables in repository and create
                  symlinks.
    update <PKG>  Update package PKG, see 'Modes' for details.

    sync [<PKG>]  Sync package PKG (or all packages with no argument),
                  i.e. check for available updates.

    list          List packages.

    set <PKG> KEY[=VAL]
                  Set metadata value of KEY to VAL (without VAL,
                  show current value).

Options:
    options for 'add':
        -t        Add package in tag-mode
        -b        Add package in branch-mode
        -u        Force using URL as is

    options for 'add' and 'reflect':
        -d        Dry-run, don't download or create files

    options for 'reflect':
        -r <DIR>  Use subdirectory DIR instead of root directory
        -R        Scan directories recursively, not just root directory

    options for 'update':
        -f        Don't stop on uncommitted changes and don't ask to
                  select tag if more than one tag are available.

Modes:
    Packages are added and updated in one of the two modes:

    tag-mode      Local repository is cloned using a tag reference.
                  In this mode, when you update a package, we search
                  for a tag that is more recent than the current one,
                  and merge the local working branch.

                  When the attribute 'tag_pattern' is set, only tags
                  matching this pattern are considered.

    branch-mode   Local repository is cloned using a branch reference
                  (often master/main). Package is updated by merging
                  last commits into the local working branch.

    The \"local working branch\" is created when a repository is cloned,
    (useful if you like to mess with the source code). The name of this
    branch is defined in the config file.
    "
}


# ----- helper functions ----- #

# Exit program with optional error message
abort() {
    [ -n "$1" ] && echo "$1" >&2
    exit 1
}


# Ask user and read yes/no answer
ask() {
    read -p "$1 [y/N]: "
    [ "$REPLY" == y ] || [ "$REPLY" == yes ]
}

# Check if user wants to proceed
check_proceed() {
    read -p "${1:-proceed?} [y/N]: "
    [ "$REPLY" == "y" ] || [ "$REPLY" == "yes" ] || exit
}


# ----- command functions ----- #


# List all packages. Print name, current head and URL.
list() {
    local pkg
    local -A md

    if [ ! ${OPTS[no_header]} ]; then
        printf "****************************** ******************** "
        printf "**************************************************\n"
        printf "%-30s %-20s %-50s\n" "package" "current head" "url"
        printf "****************************** ******************** "
        printf "**************************************************\n"
    fi

    for pkg in $(md_list); do
        md=()
        md_load $pkg
        printf "%-30s %-20s %-50s\n" "$pkg" "${md[mode]} '${md[ref]}'" "${md[url]}"
    done
}

# Show all metadata fields of package
show() {
    local -A md
    local key

    md_exists "$1" || abort "package '$1' does not exist"
    md_load "$1"

    if [ ! ${OPTS[no_header]} ]; then
        printf "****************************** **************************************************\n"
        printf "package:                       %b%s%b\n" "$BOLD" "$1" "$CLEAR"
        printf "****************************** **************************************************\n"
    fi

    for key in ${!md[@]}; do printf "%-30s " "$key"; echo ${md[$key]}; done

    [ -e "$MDD/$1/.bins" ] && printf "%-30s " "bins" && wc -l < "$MDD/$1/.bins"
    [ -e "$MDD/$1/.libs" ] && printf "%-30s " "libs" && wc -l < "$MDD/$1/.libs"
}

# Print absolute path of package. Useful to quickly
# change directory. E.g., run "cd `smog path PKG`".
path() {
    md_exists "$1" || abort "package '$1' does not exist"
    grep '^path: ' "$MDD/$1" | cut -d' ' -f2-
}

# Remove package. I.e. remove git repository, metadata and
# symbolic links (if any).
remove() {
    local p=$(path "$1")
    [ -d "$p" ] || abort "invalid path: '$p'"

	echo "warning: any local changes will be permanently lost"
    check_proceed "remove '$1'?"

    rm -rf "$p" || abort
	echo "removed repository '$p'"

	# TODO

    local -A bins libs
    local k
    md_load_links "$1"

    for k in ${!bins[@]}; do unlink "$BIN/$k" && echo "removed link '$BIN/$k'"; done
    for k in ${!libs[@]}; do unlink "$LIB/$k" && echo "removed link '$LIB/$k'"; done

    md_remove "$1"
    echo -e "${BOLD}package '$1' removed${CLEAR}"
}


# Check the URL is valid and show available refs (tags or branches).
# This is like 'add' but without creating a local package.
# TODO: mostly duplicate code - probably merge to 'add' or split 
# into reulsable functioins.
check() {
    local pkg path url="$1"

    url_parse "$url" || abort "failed to parse the URL"

    printf "\n"
    printf "%-10s: %s\n" "package" "$pkg"
    printf "%-10s: %s\n" "url" "$url"
    printf "%-10s: %s\n" "path" "$path"
    printf "\n"

    local -A refs
	local -a refsarr
    local mode ref refname sha

	check_git_refs
    local r
    for r in "${refsarr[@]}"; do echo "   * $r"; done

    echo 
    echo "  -> mode    = [$mode]"
    echo "  -> ref     = [$ref]"
    echo "  -> refname = [$refname]"
    echo "  -> refsarr = [${#refsarr[@]}]"
}

# Add a repository, i.e. check for available refs (tags or branches),
# clone the repository and create a metadata file.
add() {

    local pkg path url="$1"
    local -A md

    url_parse "$url" || abort "failed to parse the URL"

    printf "\n"
    printf "%-10s: %s\n" "package" "$pkg"
    printf "%-10s: %s\n" "url" "$url"
    printf "%-10s: %s\n" "path" "$path"
    printf "\n"

    check_proceed

    # TODO check for blanks in url/path
    md[url]=$url
    md[path]=$path

    # if URL is already used for another package
    # throw a warning
    local used=$(grep -rlE "^url: ${url}$" "$MDD/")
    if [ -n "$used" ]; then
        echo "warning: URL already used by package '`basename $used`'"
        check_proceed
    fi

    # check that pkg name is not already used
    # it's ok to have two git repositories with the same name
    # but in our metadata each package name should be unique.
    while md_exists "$pkg"; do
        echo "package name already used"
        echo "you can use an alternative name"
        read -p "use name: " pkg
		[ -n "$pkg" ] || abort
		# update path with new name
        path=$(echo "$path" | sed -E s|([^/])+$|"$pkg"|)
    done

	# check available tags/branches and which
	# ref we will use to clone the repo

    local -A refs
	local -a refsarr
    local mode ref refname sha

	check_git_refs

    # ask to confirm selected tag/branch (if any)
    if [ -n "$ref" ] && [ "$ref" != "${OPTS[$mode]}" ]; then
        read -p "use $mode [$ref]? [y/N]: "
        [ "$REPLY" == "y" ] || [ "$REPLY" == "yes" ] || ref=
    fi

    # ask to choose tag/branch if nothing is selected
    if [ -z "$ref" ]; then
        echo "choose $mode to clone"
        select ref in "${refsarr[@]}"; do break; done
    fi
        
    [ -n "$ref" ] && [ ${refs[$ref]+_} ] || abort

    md[mode]=$mode
    md[ref]=$ref
    md[sha]=${refs[$ref]}

    echo -e "${BOLD}selected $mode [$ref] [${refs[$ref]}]${CLEAR}"

	# clone the repository into the package's path
	mkdir -vp "$PKG/$path" || abort
	cd "$PKG/$path"

	echo -en "$GREY"
	$GIT clone --depth=1 -c advice.detachedHead=false -b "$ref" "$url" .
	[ $? -ne 0 ] && rm -rf "$PKG/$path" && abort

	$GIT checkout -b "${MASTERBRANCH}" 
	[ $? -ne 0 ] && rm -rf "$PKG/$path" && abort
	echo -en "$CLEAR"

    md_dump $pkg
    echo -e "${BOLD}package '$pkg' created${CLEAR}"
}

# Sync package(s) with upstream repository. With no argument, all packages
# are synced, otherwise only given packages is synced.
# When all packages are synced, this function calls itself concurrently.
sync() {

    if [ ! ${OPTS[no_header]} ]; then
        printf "****************************** ******************** "
        printf "**************************************************\n"
        printf "%-30s %-20s %s\n" "package" "current head" "status"
        printf "****************************** ******************** "
        printf "**************************************************\n"
    fi

    # Sync single package and exit
    [ -n "$1" ] && sync_pkg "$1" && return

    # Sync all packages - run 'smog PKG -n' for each package
    # (-n will prevent printing header each time)
    md_list | xargs -P ${NPROCS} -I {} $0 sync {} -n
    wait
    printf "\nsyncing complete!\n"
}

# Helper function for update:
# Check if a valid tag is available for update
check_tag_ref() {

    local tag="${OPTS[tag]-}"

    # explicitely asked to use a tag
    if [ -n "$tag" ]; then
        echo "you requested tag [$tag]"
        [ ! ${refs[$tag]+_} ] && echo "tag '$tag' not found" && return 1
        ref="$tag"
        # sanity check: if tag is not in refsarr, it might be older
        # than current tag (refsarr holds tags that are newer).
        printf '%s\n' | grep -xq "$tag"
        if [ $? -ne 0 ]; then
            echo -en "${BOLD}${RED}"
            echo "warning: '$tag' might be older than current tag '${md[ref]}'"
            echo -en "$CLEAR"
        fi
    fi

    # if a tag is selected, ask user to confirm
    if [ -n "$ref" ]; then
        ask "update to [$ref]?"
        # don't continue if only one tag is available
        if [ $? -ne 0 ]; then
            echo "answer = no"
            [ -n "$tag" ] && return 1
            [ ${#refsarr[@]} -eq 1 ] && return 1
            ref=
        else
           echo "anser = yes"
        fi
    fi

    # if nothing was selected, ask user choice
    if [ -z "$ref" ]; then
        select ref in "${refsarr[@]}"; do break; done
    fi

    echo "ref=[$ref]"
    # final test
    [ -n "$ref" ]
}


# updates a package repository:
# - in branch mode: just update to the latest commits
# - in tag mode: fetch and switch to the newer tag
# if the 'force' option is set, will try to merge any
# local changes before merging.
update() {

    local -A md

    md_load "$1" || abort "package '$1' does not exist"

    local status ref
    local -a refsarr
    local -A refs

    echo -n "checking for updates.. "

    if [ "${md[mode]}" == branch ]; then
        sync_branch "${md[url]}" "${md[ref]}" "${md[sha]}"
    elif [ "${md[mode]}" == tag ]; then
        sync_tag "${md[url]}" "${md[ref]}" "${md[tag_pattern]-}"
    else
        abort "invalid mode '${md[mode]}'"
    fi

    case $? in 
        0 ) echo "package is up-to-date"; return ;;
        1 | 2 ) echo -e "${BOLD}${status}${CLEAR}" ;;
        * ) abort "$status" ;;
    esac

    echo "ref = [$ref]"

    # If we get here, updates are available.
    # For branch mode, we just need to update local branch
    # For tag mode, multiple new tags ('releases') might
    # be avaiable, so we ask user which to choose.
    if [ "${md[mode]}" == tag ]; then
        check_tag_ref || abort 'terminated'
    fi

    # Enter package directory
    echo "entering directory '${md[path]}'"
    cd "$PKG/${md[path]}" || abort
    $GIT checkout -q "$MASTERBRANCH" || abort

    # Before fetching remote changes, make sure our
    # local branch does not gave uncommitted commits.
    echo -n "checking local changes in '$MASTERBRANCH'.. "
    if [ -z "$($GIT status -s)" ]; then
        echo "OK: clean branch"
    else
        echo
        echo "you have unstaged or uncommited changes"
        ask "create autocommit?" || abort
        echo -en "$GREY"
        # TODO: something better than 'add .'
        $GIT add . || abort
        $GIT commit -m "autocommit by $NAME" || abort
        echo -en "$CLEAR"
    fi

    # Fetch remote changes
    echo -en "$GREY"
    if [ "${md[mode]}" == tag ]; then
        $GIT fetch origin tag "$ref" || abort
        $GIT merge -m "automerge by $NAME" "$ref" || abort
        md[ref]="$ref"
    else 
        $GIT fetch origin "$ref" || abort
        md[sha]=$( $GIT log origin/"${md[ref]}" -1 --pretty=format:%H )
        $GIT merge -m "automerge by $NAME" origin/"$ref" || abort
    fi
    echo -en "$CLEAR"

    md_dump $1

    echo -en "${BOLD}package '$1' updated to "
    if [ "${md[mode]}" == tag ]; then
        echo "tag '$ref'"
    else
        echo "remote branch '$ref' [$sha]"
    fi
    echo -en "$CLEAR"
}

# scan for binaries and executables in package repository
# this command is useful after you've build a package
# TODO: poorly tested and probably very buggy
reflect() {
    local -A md
    md_exists "$1" || abort "package '$1' does not exist"
    md_load "$1"

    local dir="${md[path]}"
    # if a build directory is specified, only scan that
    if [ ${OPTS[root]} ]; then
        [ "${OPTS[root]: -1}" == "/" ] && OPTS[root]="${OPTS[root]::-1}"
        dir+="/${OPTS[root]}"
        if [ ! ${md[builddir]+_} ] || [ "${md[builddir]}" != "${OPTS[root]}" ]; then
            md[builddir]="${OPTS[root]}"
            [ ! ${OPTS[debug]} ] && md_dump "$1"
        fi
    elif [ ${md[builddir]+_} ]; then
        dir+="/${md[builddir]}"
    fi
    dir="$PKG/$dir"

    [ -d "$dir" ] || abort "directory '$dir' does not exist"
    [ -L "$dir" ] && abort "directory '$dir' is a symlink"

    local -A bins libs
    echo "scanning directory '$dir'..."
    reflect_dir "$dir"
    echo "detected ${#bins[@]} executables and ${#libs[@]} libraries"
    # don't continue if nothing detected
    [ ${#bins[@]} -eq 0 ] && [ ${#libs[@]} -eq 0 ] && return

    # show lists
    local key
    echo ""
    [ ${#bins[@]} -ne 0 ] && echo "executables:"
    for key in ${!bins[@]}; do echo " - $key"; done

    [ ${#libs[@]} -ne 0 ] && echo "libraries:"
    for key in ${!libs[@]}; do echo " - $key"; done

    read -n 1 -p "create and update links? [y/N]: "
    echo ""
    [ "$REPLY" == "y" ] || return

    if [ ${#bins[@]} -gt 1 ] || [ ${#libs[@]} -gt 1 ]; then
        read -n 1 -p "use all executables or edit the list? [a/e]: "
        echo ""
        if [ "$REPLY" == "e" ]; then
            edit_list || abort
        elif [ "$REPLY" != "a" ]; then
            return
        fi
    fi

    local target
    local -i n=${#dir}
    local -i removed=0 kept=0 added=0 libs_added=0

    echo "updating linkes ..."

    # the two directories for symlinks should exist
    [ -d "$BIN" ] || abort "directory [$BIN] does not exist"
    [ -d "$LIB" ] || abort "directory [$LIB] does not exist"

    # update links to executables
    for key in $(ls $BIN); do
        target=$(readlink $BIN/$key)
        [ -z "$target" ] && continue
        [ ${target::$n} != $dir ] && continue

        if [ ${bins[$target]+_} ]; then
            printf " %-20s %20s -> %s\n" "keep link" $key $target
            bins[$target]="$key"
            ((kept++))
        else
            printf " %-20s %20s -> %s\n" "remove dead link" $key $target
            [ ! ${OPTS[debug]} ] && unlink "$BIN/$key"
            ((removed++))
        fi
    done

    for target in ${!bins[@]}; do
        [ -n "${bins[$target]}" ] && continue
        key=$(basename $target)

        if [ -e "$BIN/$key" ]; then
            printf " %-20s %20s -> %s\n" "skip - name used" $key $target
        else
            printf " %-20s %20s -> %s\n" "create link" $key $target
            [ ! ${OPTS[debug]} ] && ln -s "$target" "$BIN/$key"
            bins[$target]="$key"
            ((added++))
        fi
    done

    # update links to shared libs
    # TODO: move to a function (almost exact same two loops)
    for key in $(ls $LIB); do
        target=$(readlink $LIB/$key)
        [ -z "$target" ] && continue
        [ ${target::$n} != $dir ] && continue

        if [ ${libs[$target]+_} ]; then
            printf " %-20s %20s -> %s\n" "keep link" $key $target
            [ ! ${OPTS[debug]} ] && libs[$target]="$key"
            ((kept++))
        else
            printf " %-20s %20s -> %s\n" "remove dead link" $key $target
            [ ! ${OPTS[debug]} ] && unlink "$LIB/$key"
            ((removed++))
        fi
    done

    for target in ${!libs[@]}; do
        [ -n "${libs[$target]}" ] && continue
        key=$(basename $target)

        if [ -e "$LIB/$key" ]; then
            printf " %-20s %20s -> %s\n" "skip - name used" $key $target
        else
            printf " %-20s %20s -> %s\n" "create link" $key $target
            [ ! ${OPTS[debug]} ] && ln -s "$target" "$LIB/$key"
            libs[$target]="$key"
            ((added++))
            ((libs_added++))
        fi
    done
    
    # report results
    echo "created $added, kept $kept, removed $removed links"
    [ $libs_added -ne 0 ] && echo "run 'sudo ldconfig' to update cache"

    # save metadata
    if [ ${OPTS[debug]} ]; then
        echo "in debug mode: nothing actually changed"
    elif [ $added -ne 0 ] || [ $removed -ne 0 ]; then
        md_dump_links "$1"
        echo "updated metadata of package '$1'"
    fi
}

# scan for executables in directory (arg).
# the full path of executables is added either
# to the AA 'bins' (if it's a binary or shell script) or
# the AA 'libs' (if it's a shared library).
#
# if the 'recursive' option is set, runs recursively
# in subdirectories.
reflect_dir() {
    local f p t
    for f in $(ls $1); do
        p="$1/$f"
        [ -L "$p" ] && continue
        [ -d "$p" ] && [ ${OPTS[recursive]} ] && reflect_dir "$p" && continue
        [ -x "$p" ] || continue

        t=$(file -b --mime-type "$p" | sed -E 's|.*-([a-z]+)$|\1|')
        case "$t" in
            shellscript | executable ) bins[$p]='' ;;
            sharedlib )   libs[$p]='' ;;
        esac
    done
}

edit_lists() {
    echo "'${FUNCNAME[0]}' not implemented yet"
    return

    # wip
    local f
    echo -e ":$PINK"
    for f in "${bins[@]}"; do echo " - $f"; done;
    echo -e "$CLEAR"

    echo ""
    echo "you can choose to use all, none or edit the list"
    read -p "[a]ll, [e]edit, [N]othing: "

    if [ "${REPLY::1}" == "a" ]; then
        ${md[bins]}=bins
    elif [ "${REPLY::1}" == "e" ]; then
        local tmpf="_tmp_smog_$1_bins.txt"
        local ok
        echo ${bins[@]} | tr ' ' '\n' > $tmpf
        $EDITOR $tmpf
        unset bins
        readarray -t bins <<< $(cat $tmpf)
        rm $tmpf
        ${md[bins]}=bins
    else
        echo "stopping"
        return
    fi
}


# ---- main routine ---- #

# DEBUG
#echo -en "\033[90m"

# figure out home directory and load config
[ -L "$0" ] && confp=$(dirname $(readlink $0))/config.sh || confp=$(dirname $0)/config.sh
. $confp || abort "can't load '$confp'"

# TODO: remove cd && use $SMOG_PATH
cd `dirname $confp`

declare LIBS
LIBS=$(ls util) || abort

while read -r lib; do
    . util/$lib || abort
    #echo "loaded '$lib'"
done <<< $LIBS
unset LIBS

declare CMD ARG1 ARG2
declare -A OPTS

CMD=$1

case $CMD in
    add | check )
        [ -z $2 ] && abort "missing <URL>"
        [ "${2:0:1}" == "-" ] && abort "invalid <URL>"
        ARG1=$2
        shift 2 ;;
    set )
        [ -z $2 ] && abort "missing <PKG>"
        [ -z "$3" ] && abort "missing <KEY>"
        ARG1=$2
        ARG2=$3
        shift 3 ;;
    remove | show | path | update | reflect )
        [ -z $2 ] && abort "missing <PKG>"
        [ "${2:0:1}" == "-" ] && abort "invalid <PKG>"
        ARG1=$2
        shift 2 ;;
    sync )
        [ -n "$2" ] && [ "${2:0:1}" != "-" ] && { ARG1=$2; shift 2; } || shift 1 ;;
    list )
        shift 1 ;;
    help | -h | --help )
        usage
        exit 0 ;;
    version )
        version
        exit 0 ;;
    * )
        [ -z $CMD ] && abort "missing command"
        abort "invalid command '$CMD'" ;;
esac

while getopts 'vdtbnrfuR:T:B:' opt; do
    case $opt in
        v ) OPTS[verbose]=true ;;
        d ) OPTS[debug]=true ;;
        t ) OPTS[mode]=tag ;;
        b ) OPTS[mode]=branch ;;
        n ) OPTS[no_header]=true ;;
        r ) OPTS[recursive]=true ;;
        f ) OPTS[force]=true ;;
        u ) OPTS[url]=true ;;
        R ) OPTS[root]="$OPTARG" ;;
		T ) OPTS[tag]="$OPTARG" ;;
		B ) OPTS[branch]="$OPTARG" ;;
        ? ) abort ;;
    esac
done

#echo "CMD=[$CMD] - ARG1=[$ARG1] - ARG2=[$ARG2]"
#echo -en "\033[0m"

$CMD $ARG1 $ARG2
